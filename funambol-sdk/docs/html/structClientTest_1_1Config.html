<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Funambol C++ Client Library: ClientTest::Config Struct Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="classClientTest.html">ClientTest</a>::<a class="el" href="structClientTest_1_1Config.html">Config</a></div>
<h1>ClientTest::Config Struct Reference</h1><!-- doxytag: class="ClientTest::Config" -->Information about a data source.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="ClientTest_8h-source.html">ClientTest.h</a>&gt;</code>
<p>
<a href="structClientTest_1_1Config-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classSyncSource.html">SyncSource</a> *(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#f7d2815b26c8007d45eac2f5cfb3a232">createsource_t</a> (<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, int source, bool isSourceA)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A member function of a subclass which is called to create a sync source referencing the data.  <a href="#f7d2815b26c8007d45eac2f5cfb3a232"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="13606b71a37c3d8b9bac91c208a8de00"></a><!-- doxytag: member="ClientTest::Config::sourceName" ref="13606b71a37c3d8b9bac91c208a8de00" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#13606b71a37c3d8b9bac91c208a8de00">sourceName</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The name is used in test names and has to be set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c54fca23378e04c6910e9b85d87fefcd"></a><!-- doxytag: member="ClientTest::Config::uri" ref="c54fca23378e04c6910e9b85d87fefcd" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#c54fca23378e04c6910e9b85d87fefcd">uri</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A default URI to be used when creating a client config. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4b88084e4d9abe94aa4e5ab37c4d0b13"></a><!-- doxytag: member="ClientTest::Config::createSourceA" ref="4b88084e4d9abe94aa4e5ab37c4d0b13" args="" -->
<a class="el" href="structClientTest_1_1Config.html#f7d2815b26c8007d45eac2f5cfb3a232">createsource_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#4b88084e4d9abe94aa4e5ab37c4d0b13">createSourceA</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a sync source which references the primary database; it may report the same changes as the sync source used during sync tests. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structClientTest_1_1Config.html#f7d2815b26c8007d45eac2f5cfb3a232">createsource_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#9d8b5a3de6b9ddd500e44aaff9d59b7e">createSourceB</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A second sync source also referencing the primary data source, but configured so that it tracks changes independently from the the primary sync source.  <a href="#9d8b5a3de6b9ddd500e44aaff9d59b7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#c3d389ac3acec40f2fa370fcaac411b7">templateItem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The framework can generate vCard and vCalendar/iCalendar items automatically by copying a template item and modifying certain properties.  <a href="#c3d389ac3acec40f2fa370fcaac411b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="63ce67039c12f690bf0cb7b2c2830e1b"></a><!-- doxytag: member="ClientTest::Config::uniqueProperties" ref="63ce67039c12f690bf0cb7b2c2830e1b" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#63ce67039c12f690bf0cb7b2c2830e1b">uniqueProperties</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a colon (:) separated list of properties which need to be modified in templateItem. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="17621cc1f53f352e94c4d34274902bfe"></a><!-- doxytag: member="ClientTest::Config::numItems" ref="17621cc1f53f352e94c4d34274902bfe" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#17621cc1f53f352e94c4d34274902bfe">numItems</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the number of items to create during stress tests <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1cb2cbb515ed39152bf4b8244a12867e"></a><!-- doxytag: member="ClientTest::Config::sizeProperty" ref="1cb2cbb515ed39152bf4b8244a12867e" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#1cb2cbb515ed39152bf4b8244a12867e">sizeProperty</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a single property in templateItem which can be extended to increase the size of generated items. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#a21023ae78b155bcca67d1a2ed00f83e">insertItem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A very simple item that is inserted during basic tests.  <a href="#a21023ae78b155bcca67d1a2ed00f83e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#810beeb15d5f135d1c2e5e5e6127050f">updateItem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A slightly modified version of insertItem.  <a href="#810beeb15d5f135d1c2e5e5e6127050f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#cea02c72b4078113996f6eb274ac2432">complexUpdateItem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A more heavily modified version of insertItem.  <a href="#cea02c72b4078113996f6eb274ac2432"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#3b8b6d8c7f74ab9f92cf28039db04393">mergeItem1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To test merge conflicts two different updates of insertItem are needed.  <a href="#3b8b6d8c7f74ab9f92cf28039db04393"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#695b04d1081ffc6adf34671fe5fb1c8d">mergeItem2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The second merge update item.  <a href="#695b04d1081ffc6adf34671fe5fb1c8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#d3cd2429f410c55e13423be854a826a9">parentItem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">These two items are related: one is main one, the other is a subordinate one.  <a href="#d3cd2429f410c55e13423be854a826a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="97dc9112bc673d274971e9a6611110a6"></a><!-- doxytag: member="ClientTest::Config::childItem" ref="97dc9112bc673d274971e9a6611110a6" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>childItem</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#ad002cdd4f767eec8c7f30b8d186ef8e">dump</a> )(<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, <a class="el" href="classSyncSource.html">SyncSource</a> &amp;source, const char *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">called to dump all items into a file, required by tests which need to compare items  <a href="#ad002cdd4f767eec8c7f30b8d186ef8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#f590f3b6b652dfb0fa566dc1440f3f11">import</a> )(<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, <a class="el" href="classSyncSource.html">SyncSource</a> &amp;source, const char *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">import test items: which these are is determined entirely by the implementor, but tests work best if several complex items are imported  <a href="#f590f3b6b652dfb0fa566dc1440f3f11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#5ac4b98364b1c16007cc9af1f0b423dd">compare</a> )(<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, const char *fileA, const char *fileB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a function which compares two files with items in the format used by "dump"  <a href="#5ac4b98364b1c16007cc9af1f0b423dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="024fe82b49035455a6602ed00f6d203f"></a><!-- doxytag: member="ClientTest::Config::testcases" ref="024fe82b49035455a6602ed00f6d203f" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#024fe82b49035455a6602ed00f6d203f">testcases</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a file with test cases in the format expected by import and compare <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e6c8c571c3424b35ebf771e5a2dee6a0"></a><!-- doxytag: member="ClientTest::Config::type" ref="e6c8c571c3424b35ebf771e5a2dee6a0" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structClientTest_1_1Config.html#e6c8c571c3424b35ebf771e5a2dee6a0">type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the item type normally used by the source (not used by the tests themselves; client-test.cpp uses it to initialize source configs) <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Information about a data source. 
<p>
For the sake of simplicity all items pointed to are owned by the <a class="el" href="classClientTest.html">ClientTest</a> and must remain valid throughout a test session. Not setting a pointer is okay, but it will disable all tests that need the information. 
<p>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="f7d2815b26c8007d45eac2f5cfb3a232"></a><!-- doxytag: member="ClientTest::Config::createsource_t" ref="f7d2815b26c8007d45eac2f5cfb3a232" args="(ClientTest &amp;client, int source, bool isSourceA)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classSyncSource.html">SyncSource</a>*(*) <a class="el" href="structClientTest_1_1Config.html#f7d2815b26c8007d45eac2f5cfb3a232">ClientTest::Config::createsource_t</a>(<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, int source, bool isSourceA)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A member function of a subclass which is called to create a sync source referencing the data. 
<p>
This is used in tests of the <a class="el" href="classSyncSource.html">SyncSource</a> API itself as well as in tests which need to modify or check the data sources used during synchronization.<p>
The test framework will call beginSync() and then some of the functions it wants to test. After a successful test it will call endSync() which is then expected to store all changes persistently. Creating a sync source again with the same call should not report any new/updated/deleted items until such changes are made via another sync source.<p>
The instance will be deleted by the caller. Because this may be in the error case or in an exception handler, the sync source's desctructor should not thow exceptions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>client</em>&nbsp;</td><td>the same instance to which this config belongs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>index of the data source (from 0 to <a class="el" href="classClientTest.html#d7b3592d2623c8076ffc43c4600a2f16">ClientTest::getNumSources()</a> - 1) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isSourceA</em>&nbsp;</td><td>true if the requested <a class="el" href="classSyncSource.html">SyncSource</a> is the first one accessing that data, otherwise the second </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="9d8b5a3de6b9ddd500e44aaff9d59b7e"></a><!-- doxytag: member="ClientTest::Config::createSourceB" ref="9d8b5a3de6b9ddd500e44aaff9d59b7e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structClientTest_1_1Config.html#f7d2815b26c8007d45eac2f5cfb3a232">createsource_t</a> <a class="el" href="structClientTest_1_1Config.html#9d8b5a3de6b9ddd500e44aaff9d59b7e">ClientTest::Config::createSourceB</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A second sync source also referencing the primary data source, but configured so that it tracks changes independently from the the primary sync source. 
<p>
In local tests the usage is like this:<ul>
<li>add item via first <a class="el" href="classSyncSource.html">SyncSource</a></li><li>iterate over new items in second <a class="el" href="classSyncSource.html">SyncSource</a></li><li>check that it lists the added item</li></ul>
<p>
In tests with a server the usage is:<ul>
<li>do a synchronization with the server</li><li>iterate over items in second <a class="el" href="classSyncSource.html">SyncSource</a></li><li>check that the total number and number of added/updated/deleted items is as expected </li></ul>

</div>
</div><p>
<a class="anchor" name="c3d389ac3acec40f2fa370fcaac411b7"></a><!-- doxytag: member="ClientTest::Config::templateItem" ref="c3d389ac3acec40f2fa370fcaac411b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="structClientTest_1_1Config.html#c3d389ac3acec40f2fa370fcaac411b7">ClientTest::Config::templateItem</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The framework can generate vCard and vCalendar/iCalendar items automatically by copying a template item and modifying certain properties. 
<p>
This is the template for these automatically generated items. 
</div>
</div><p>
<a class="anchor" name="a21023ae78b155bcca67d1a2ed00f83e"></a><!-- doxytag: member="ClientTest::Config::insertItem" ref="a21023ae78b155bcca67d1a2ed00f83e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="structClientTest_1_1Config.html#a21023ae78b155bcca67d1a2ed00f83e">ClientTest::Config::insertItem</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A very simple item that is inserted during basic tests. 
<p>
Ideally it only contains properties supported by all servers. 
</div>
</div><p>
<a class="anchor" name="810beeb15d5f135d1c2e5e5e6127050f"></a><!-- doxytag: member="ClientTest::Config::updateItem" ref="810beeb15d5f135d1c2e5e5e6127050f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="structClientTest_1_1Config.html#810beeb15d5f135d1c2e5e5e6127050f">ClientTest::Config::updateItem</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A slightly modified version of insertItem. 
<p>
If the source has UIDs embedded into the item data, then both must have the same UID. Again all servers should better support these modified properties. 
</div>
</div><p>
<a class="anchor" name="cea02c72b4078113996f6eb274ac2432"></a><!-- doxytag: member="ClientTest::Config::complexUpdateItem" ref="cea02c72b4078113996f6eb274ac2432" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="structClientTest_1_1Config.html#cea02c72b4078113996f6eb274ac2432">ClientTest::Config::complexUpdateItem</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A more heavily modified version of insertItem. 
<p>
Same UID if necessary, but can test changes to items only supported by more advanced servers. 
</div>
</div><p>
<a class="anchor" name="3b8b6d8c7f74ab9f92cf28039db04393"></a><!-- doxytag: member="ClientTest::Config::mergeItem1" ref="3b8b6d8c7f74ab9f92cf28039db04393" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="structClientTest_1_1Config.html#3b8b6d8c7f74ab9f92cf28039db04393">ClientTest::Config::mergeItem1</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To test merge conflicts two different updates of insertItem are needed. 
<p>
This is the first such update. 
</div>
</div><p>
<a class="anchor" name="695b04d1081ffc6adf34671fe5fb1c8d"></a><!-- doxytag: member="ClientTest::Config::mergeItem2" ref="695b04d1081ffc6adf34671fe5fb1c8d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="structClientTest_1_1Config.html#695b04d1081ffc6adf34671fe5fb1c8d">ClientTest::Config::mergeItem2</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The second merge update item. 
<p>
To avoid true conflicts it should update different properties than mergeItem1, but even then servers usually have problems perfectly merging items. Therefore the test is run without expecting a certain merge result. 
</div>
</div><p>
<a class="anchor" name="d3cd2429f410c55e13423be854a826a9"></a><!-- doxytag: member="ClientTest::Config::parentItem" ref="d3cd2429f410c55e13423be854a826a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="structClientTest_1_1Config.html#d3cd2429f410c55e13423be854a826a9">ClientTest::Config::parentItem</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
These two items are related: one is main one, the other is a subordinate one. 
<p>
The semantic is that the main item is complete on it its own, while the other normally should only be used in combination with the main one.<p>
Because SyncML cannot express such dependencies between items, a <a class="el" href="classSyncSource.html">SyncSource</a> has to be able to insert, updated and remove both items independently. However, operations which violate the semantic of the related items (like deleting the parent, but not the child) may have unspecified results (like also deleting the child). See LINKED_ITEMS_RELAXED_SEMANTIC.<p>
One example for main and subordinate items are a recurring iCalendar 2.0 event and a detached recurrence. 
</div>
</div><p>
<a class="anchor" name="ad002cdd4f767eec8c7f30b8d186ef8e"></a><!-- doxytag: member="ClientTest::Config::dump" ref="ad002cdd4f767eec8c7f30b8d186ef8e" args=")(ClientTest &amp;client, SyncSource &amp;source, const char *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structClientTest_1_1Config.html#ad002cdd4f767eec8c7f30b8d186ef8e">ClientTest::Config::dump</a>)(<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, <a class="el" href="classSyncSource.html">SyncSource</a> &amp;source, const char *file)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
called to dump all items into a file, required by tests which need to compare items 
<p>
<a class="el" href="group__ClientTest.html#g21f82c79cc49a242a9ddb28ccc4ae4cf">ClientTest::dump</a> can be used: it will simply dump all items of the source with a blank line as separator.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>sync source A already created and with beginSync() called </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>a file name </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>error code, 0 for success </dd></dl>

</div>
</div><p>
<a class="anchor" name="f590f3b6b652dfb0fa566dc1440f3f11"></a><!-- doxytag: member="ClientTest::Config::import" ref="f590f3b6b652dfb0fa566dc1440f3f11" args=")(ClientTest &amp;client, SyncSource &amp;source, const char *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structClientTest_1_1Config.html#f590f3b6b652dfb0fa566dc1440f3f11">ClientTest::Config::import</a>)(<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, <a class="el" href="classSyncSource.html">SyncSource</a> &amp;source, const char *file)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
import test items: which these are is determined entirely by the implementor, but tests work best if several complex items are imported 
<p>
<a class="el" href="group__ClientTest.html#g6f8c5e62da7b5da62d4bf5e5f9f8938e">ClientTest::import</a> can be used if the file contains items separated by empty lines.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>sync source A already created and with beginSync() called </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>the name of the file to import </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>error code, 0 for success </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ac4b98364b1c16007cc9af1f0b423dd"></a><!-- doxytag: member="ClientTest::Config::compare" ref="5ac4b98364b1c16007cc9af1f0b423dd" args=")(ClientTest &amp;client, const char *fileA, const char *fileB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* <a class="el" href="structClientTest_1_1Config.html#5ac4b98364b1c16007cc9af1f0b423dd">ClientTest::Config::compare</a>)(<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, const char *fileA, const char *fileB)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
a function which compares two files with items in the format used by "dump" 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fileA</em>&nbsp;</td><td>first file name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fileB</em>&nbsp;</td><td>second file name </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the content of the files is considered equal </dd></dl>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>test/<a class="el" href="ClientTest_8h-source.html">ClientTest.h</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Jul 25 15:04:18 2008 for Funambol C++ Client Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
