<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Funambol C++ Client Library: Client Testing Framework</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1>Client Testing Framework</h1>The testing framework of the C++ client library is based on CPPUnit.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ClientOutputter</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ClientListener</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTestFileSource.html">TestFileSource</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This code uses the <a class="el" href="classClientTest.html">ClientTest</a> and <a class="el" href="classRawFileSyncSource.html">RawFileSyncSource</a> to test real synchronization against a server.  <a href="classTestFileSource.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>RegisterTest</b></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the only purpose of this class is to own the first <a class="el" href="classTestFileSource.html">TestFileSource</a> and to register its tests at program startup <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClientTestFactory.html">ClientTestFactory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generates tests on demand based on what the client supports  <a href="classClientTestFactory.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0e303fd8fed6073ee862d6078a6369fd"></a><!-- doxytag: member="ClientTest::simplifyFilename" ref="g0e303fd8fed6073ee862d6078a6369fd" args="(string &amp;filename)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>simplifyFilename</b> (string &amp;filename)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7cfc20a326e05788893bfeb6fb252100"></a><!-- doxytag: member="ClientTest::getCurrentTest" ref="g7cfc20a326e05788893bfeb6fb252100" args="()" -->
const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>getCurrentTest</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0ddf1224851353fc92bfbff6f499fa97"></a><!-- doxytag: member="ClientTest::main" ref="g0ddf1224851353fc92bfbff6f499fa97" args="(int argc, char *argv[])" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>main</b> (int argc, char *argv[])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb78596a2d51bbd6484ef38c02926ea42"></a><!-- doxytag: member="ClientTest::listItemsOfType" ref="gb78596a2d51bbd6484ef38c02926ea42" args="(SyncSource *source, itemType type)" -->
std::list&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#gb78596a2d51bbd6484ef38c02926ea42">listItemsOfType</a> (<a class="el" href="classSyncSource.html">SyncSource</a> *source, itemType type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generates list of UIDs in the specified kind of items <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#gb4b747156b72636a3b7048dcc1787799">countItemsOfType</a> (<a class="el" href="classSyncSource.html">SyncSource</a> *source, itemType type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">utility function which counts items of a certain kind known to the sync source  <a href="#gb4b747156b72636a3b7048dcc1787799"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc3e4e003deabd7387730dd5747f85153"></a><!-- doxytag: member="ClientTest::countEqual" ref="gc3e4e003deabd7387730dd5747f85153" args="(const T &amp;container, const V &amp;value)" -->
template&lt;class T, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>countEqual</b> (const T &amp;container, const V &amp;value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga75ca0b749c031d14d99f11ad72fa3dd"></a><!-- doxytag: member="ClientTest::addTests" ref="ga75ca0b749c031d14d99f11ad72fa3dd" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#ga75ca0b749c031d14d99f11ad72fa3dd">LocalTests::addTests</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">adds the supported tests to the instance itself; this is the function that a derived class can override to add additional tests <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g97b2b3724b5378862453e8ddf4a1fa80">LocalTests::insert</a> (<a class="el" href="classCreateSource.html">CreateSource</a> createSource, const char *data, bool relaxed=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">opens source and inserts the given item; can be called regardless whether the data source already contains items or not  <a href="#g97b2b3724b5378862453e8ddf4a1fa80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g6d20c34c6796ec6caec7bfc19be3270d">LocalTests::update</a> (<a class="el" href="classCreateSource.html">CreateSource</a> createSource, const char *data, bool check=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assumes that exactly one element is currently inserted and updates it with the given item  <a href="#g6d20c34c6796ec6caec7bfc19be3270d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g85fef3b837faa5952472285c0f460faf"></a><!-- doxytag: member="ClientTest::deleteAll" ref="g85fef3b837faa5952472285c0f460faf" args="(CreateSource createSource)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g85fef3b837faa5952472285c0f460faf">LocalTests::deleteAll</a> (<a class="el" href="classCreateSource.html">CreateSource</a> createSource)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">deletes all items locally via sync source <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#ga71193120c1176e08647ccdf9e5f4548">LocalTests::compareDatabases</a> (const char *refFile, <a class="el" href="classSyncSource.html">SyncSource</a> &amp;copy, bool raiseAssert=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">takes two databases, exports them, then compares them using synccompare  <a href="#ga71193120c1176e08647ccdf9e5f4548"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g08c17db8b00624d8dc940d882dc8a336">LocalTests::insertManyItems</a> (<a class="el" href="classCreateSource.html">CreateSource</a> createSource, int startIndex=1, int numItems=0, int size=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">insert artificial items, number of them determined by TEST_EVOLUTION_NUM_ITEMS unless passed explicitly  <a href="#g08c17db8b00624d8dc940d882dc8a336"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g86523e51eeb7f4b2f9af40483952a13d"></a><!-- doxytag: member="ClientTest::testOpen" ref="g86523e51eeb7f4b2f9af40483952a13d" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testOpen</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge859169c3e1f1306be4b7fdb74635c08"></a><!-- doxytag: member="ClientTest::testIterateTwice" ref="ge859169c3e1f1306be4b7fdb74635c08" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testIterateTwice</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4f6150f962c87e26e04462237471eb59"></a><!-- doxytag: member="ClientTest::testSimpleInsert" ref="g4f6150f962c87e26e04462237471eb59" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testSimpleInsert</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g51dc0792ddba8ef6edafa0cf14b9e0fa"></a><!-- doxytag: member="ClientTest::testLocalDeleteAll" ref="g51dc0792ddba8ef6edafa0cf14b9e0fa" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLocalDeleteAll</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g33765a5f9ea2b98b9f5db89e45275603"></a><!-- doxytag: member="ClientTest::testComplexInsert" ref="g33765a5f9ea2b98b9f5db89e45275603" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testComplexInsert</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gfe4acc8d97f4c4511b07f1283254aecc"></a><!-- doxytag: member="ClientTest::testLocalUpdate" ref="gfe4acc8d97f4c4511b07f1283254aecc" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLocalUpdate</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9eafd5c7f66ec1a01130fe906bf4fbf4"></a><!-- doxytag: member="ClientTest::testChanges" ref="g9eafd5c7f66ec1a01130fe906bf4fbf4" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testChanges</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g18af29fdc3e8816478d535fc80809ed2"></a><!-- doxytag: member="ClientTest::testImport" ref="g18af29fdc3e8816478d535fc80809ed2" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testImport</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1f87c00619bf71f26ae9a7a35e410803"></a><!-- doxytag: member="ClientTest::testImportDelete" ref="g1f87c00619bf71f26ae9a7a35e410803" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testImportDelete</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc79d3081b27df1fd5c12070a23f7dc0f"></a><!-- doxytag: member="ClientTest::testManyChanges" ref="gc79d3081b27df1fd5c12070a23f7dc0f" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testManyChanges</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8265afa4aecbf4e83018e0f548240f78"></a><!-- doxytag: member="ClientTest::testLinkedItemsParent" ref="g8265afa4aecbf4e83018e0f548240f78" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsParent</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3a1ceae09c7df3f02f6f53eb881cb6c6"></a><!-- doxytag: member="ClientTest::testLinkedItemsChild" ref="g3a1ceae09c7df3f02f6f53eb881cb6c6" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsChild</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g354b51e8adb792f812f055833f19d646"></a><!-- doxytag: member="ClientTest::testLinkedItemsParentChild" ref="g354b51e8adb792f812f055833f19d646" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsParentChild</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4584aad53aa76ed65407f11b688728bf"></a><!-- doxytag: member="ClientTest::testLinkedItemsChildParent" ref="g4584aad53aa76ed65407f11b688728bf" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsChildParent</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4fb2e1ea39ad207556b9ce3e2f2de7a1"></a><!-- doxytag: member="ClientTest::testLinkedItemsChildChangesParent" ref="g4fb2e1ea39ad207556b9ce3e2f2de7a1" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsChildChangesParent</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g45620d674aa31cc534509c7064da284d"></a><!-- doxytag: member="ClientTest::testLinkedItemsRemoveParentFirst" ref="g45620d674aa31cc534509c7064da284d" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsRemoveParentFirst</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9ddb7acaef74dbb7bc27422c5b74181f"></a><!-- doxytag: member="ClientTest::testLinkedItemsRemoveNormal" ref="g9ddb7acaef74dbb7bc27422c5b74181f" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsRemoveNormal</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2e2b4217c211ea719388105619d45a60"></a><!-- doxytag: member="ClientTest::testLinkedItemsInsertParentTwice" ref="g2e2b4217c211ea719388105619d45a60" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsInsertParentTwice</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6ee12660ef78fad16d27748ff20d8183"></a><!-- doxytag: member="ClientTest::testLinkedItemsInsertChildTwice" ref="g6ee12660ef78fad16d27748ff20d8183" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsInsertChildTwice</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge05a18788fbdd8360b4a10721036beb7"></a><!-- doxytag: member="ClientTest::testLinkedItemsParentUpdate" ref="ge05a18788fbdd8360b4a10721036beb7" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsParentUpdate</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g530727d8122c69b8008be62652af7755"></a><!-- doxytag: member="ClientTest::testLinkedItemsUpdateChild" ref="g530727d8122c69b8008be62652af7755" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsUpdateChild</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5d0e06ba1cac19805ec0d7d0dfbe21e7"></a><!-- doxytag: member="ClientTest::testLinkedItemsInsertBothUpdateChild" ref="g5d0e06ba1cac19805ec0d7d0dfbe21e7" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsInsertBothUpdateChild</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7eab80ca6d905dffba6552f8a965fe1d"></a><!-- doxytag: member="ClientTest::testLinkedItemsInsertBothUpdateParent" ref="g7eab80ca6d905dffba6552f8a965fe1d" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>LocalTests::testLinkedItemsInsertBothUpdateParent</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8151b4754ebada4c91ba7b3357c09340"></a><!-- doxytag: member="ClientTest::SyncTests" ref="g8151b4754ebada4c91ba7b3357c09340" args="(const std::string &amp;name, ClientTest &amp;cl, std::vector&lt; int &gt; sourceIndices, bool isClientA=true)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::SyncTests</b> (const std::string &amp;name, <a class="el" href="classClientTest.html">ClientTest</a> &amp;cl, std::vector&lt; int &gt; sourceIndices, bool isClientA=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0c115370b643f0ae29651ec5eca96ac6"></a><!-- doxytag: member="ClientTest::addTests" ref="g0c115370b643f0ae29651ec5eca96ac6" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g0c115370b643f0ae29651ec5eca96ac6">SyncTests::addTests</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">adds the supported tests to the instance itself <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9a35819a2444dfc014d80829e3e66854"></a><!-- doxytag: member="ClientTest::compareDatabases" ref="g9a35819a2444dfc014d80829e3e66854" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g9a35819a2444dfc014d80829e3e66854">SyncTests::compareDatabases</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compare databases of first and second client <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gbee1a8b27486370ceaf62de22484f860"></a><!-- doxytag: member="ClientTest::deleteAll" ref="gbee1a8b27486370ceaf62de22484f860" args="(DeleteAllMode mode=DELETE_ALL_SYNC)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#gbee1a8b27486370ceaf62de22484f860">SyncTests::deleteAll</a> (DeleteAllMode mode=DELETE_ALL_SYNC)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">deletes all items locally and on server <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g277e3859a0a4a53e6aaf07be7e9f2270"></a><!-- doxytag: member="ClientTest::doCopy" ref="g277e3859a0a4a53e6aaf07be7e9f2270" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g277e3859a0a4a53e6aaf07be7e9f2270">SyncTests::doCopy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get both clients in sync with empty server, then copy one item from client A to B <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6b95430e46d700d243c0bc6183af857c"></a><!-- doxytag: member="ClientTest::refreshClient" ref="g6b95430e46d700d243c0bc6183af857c" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g6b95430e46d700d243c0bc6183af857c">SyncTests::refreshClient</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">replicate server database locally: same as SYNC_REFRESH_FROM_SERVER, but done with explicit local delete and then a SYNC_SLOW because some servers do no support SYNC_REFRESH_FROM_SERVER <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4007a8f7fc5f6eef8c4f8b4957b6a2ef"></a><!-- doxytag: member="ClientTest::testDeleteAllRefresh" ref="g4007a8f7fc5f6eef8c4f8b4957b6a2ef" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testDeleteAllRefresh</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g88497822126fdca142e29c13798b3170"></a><!-- doxytag: member="ClientTest::testRefreshSemantic" ref="g88497822126fdca142e29c13798b3170" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testRefreshSemantic</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g593aab56531693a8ea4e1333aa0d07cf"></a><!-- doxytag: member="ClientTest::testRefreshStatus" ref="g593aab56531693a8ea4e1333aa0d07cf" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testRefreshStatus</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5649b3f5b06d88f0f1778a4a223c1bdc"></a><!-- doxytag: member="ClientTest::testUpdate" ref="g5649b3f5b06d88f0f1778a4a223c1bdc" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testUpdate</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2dabee0fa3793d4ffd0ce88687f2ff48"></a><!-- doxytag: member="ClientTest::testComplexUpdate" ref="g2dabee0fa3793d4ffd0ce88687f2ff48" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testComplexUpdate</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga24dfca5868f14752ea9a166b0343bba"></a><!-- doxytag: member="ClientTest::testDelete" ref="ga24dfca5868f14752ea9a166b0343bba" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testDelete</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7c550ddd9d45d65777407b9c737302b8"></a><!-- doxytag: member="ClientTest::testMerge" ref="g7c550ddd9d45d65777407b9c737302b8" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testMerge</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8886b48ecb10aa8095cb8c241c73bc4f"></a><!-- doxytag: member="ClientTest::testTwinning" ref="g8886b48ecb10aa8095cb8c241c73bc4f" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testTwinning</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g848f373e16d8147f91d317c305727d99"></a><!-- doxytag: member="ClientTest::testOneWayFromServer" ref="g848f373e16d8147f91d317c305727d99" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testOneWayFromServer</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6cbd4840faf86736f179b2fdbe1cdeb5"></a><!-- doxytag: member="ClientTest::testOneWayFromClient" ref="g6cbd4840faf86736f179b2fdbe1cdeb5" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testOneWayFromClient</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7cf4398a50d643e0008917183cd4fc80"></a><!-- doxytag: member="ClientTest::testItems" ref="g7cf4398a50d643e0008917183cd4fc80" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testItems</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g543f7ddc2a38b12121f8ba645938e01d"></a><!-- doxytag: member="ClientTest::testAddUpdate" ref="g543f7ddc2a38b12121f8ba645938e01d" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testAddUpdate</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7c3fcd639c65121b128297b98bf61f2e"></a><!-- doxytag: member="ClientTest::testManyItems" ref="g7c3fcd639c65121b128297b98bf61f2e" args="()" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SyncTests::testManyItems</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb52b1e85cb76057d7f7cb44d63945536"></a><!-- doxytag: member="ClientTest::doVarSizes" ref="gb52b1e85cb76057d7f7cb44d63945536" args="(bool withMaxMsgSize, bool withLargeObject, const char *encoding)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#gb52b1e85cb76057d7f7cb44d63945536">SyncTests::doVarSizes</a> (bool withMaxMsgSize, bool withLargeObject, const char *encoding)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">implements testMaxMsg(), testLargeObject(), testLargeObjectEncoded() using a sequence of items with varying sizes <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5c9078363c9e5d1e0b1cad7007bf6131"></a><!-- doxytag: member="ClientTest::sync" ref="g5c9078363c9e5d1e0b1cad7007bf6131" args="(SyncMode syncMode, const std::string &amp;logprefix=&quot;&quot;, CheckSyncReport checkReport=CheckSyncReport(), long maxMsgSize=0, long maxObjSize=0, bool loSupport=false, const char *encoding=&quot;&quot;)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g5c9078363c9e5d1e0b1cad7007bf6131">SyncTests::sync</a> (SyncMode syncMode, const std::string &amp;logprefix=&quot;&quot;, <a class="el" href="classCheckSyncReport.html">CheckSyncReport</a> checkReport=<a class="el" href="classCheckSyncReport.html">CheckSyncReport</a>(), long maxMsgSize=0, long maxObjSize=0, bool loSupport=false, const char *encoding=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">executes a sync with the given options, checks the result and (optionally) the sync report <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g44bbf4c7cf9b7dbce51b9f4eacf5a064">ClientTest::registerTests</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function registers tests using this instance of <a class="el" href="classClientTest.html">ClientTest</a> for later use during a test run.  <a href="#g44bbf4c7cf9b7dbce51b9f4eacf5a064"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf569060e4a730e4f48c44076a32a496a"></a><!-- doxytag: member="ClientTest::ClientTest" ref="gf569060e4a730e4f48c44076a32a496a" args="(int serverSleepSec=0, const std::string &amp;serverLog=&quot;&quot;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>ClientTest::ClientTest</b> (int serverSleepSec=0, const std::string &amp;serverLog=&quot;&quot;)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classLocalTests.html">LocalTests</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g26ded0f915248600703d73380b3b3b24">ClientTest::createLocalTests</a> (const std::string &amp;name, int sourceParam, <a class="el" href="structClientTest_1_1Config.html">ClientTest::Config</a> &amp;co)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an instance of <a class="el" href="classLocalTests.html">LocalTests</a> (default implementation) or a class derived from it.  <a href="#g26ded0f915248600703d73380b3b3b24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classSyncTests.html">SyncTests</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g0fa32aef3b2e3423b12e6ae3df7a596c">ClientTest::createSyncTests</a> (const std::string &amp;name, std::vector&lt; int &gt; sourceIndices, bool isClientA=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an instance of <a class="el" href="classSyncTests.html">SyncTests</a> (default) or a class derived from it.  <a href="#g0fa32aef3b2e3423b12e6ae3df7a596c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g21f82c79cc49a242a9ddb28ccc4ae4cf"></a><!-- doxytag: member="ClientTest::dump" ref="g21f82c79cc49a242a9ddb28ccc4ae4cf" args="(ClientTest &amp;client, SyncSource &amp;source, const char *file)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g21f82c79cc49a242a9ddb28ccc4ae4cf">ClientTest::dump</a> (<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, <a class="el" href="classSyncSource.html">SyncSource</a> &amp;source, const char *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">utility function for dumping items which are C strings with blank lines as separator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6f8c5e62da7b5da62d4bf5e5f9f8938e"></a><!-- doxytag: member="ClientTest::import" ref="g6f8c5e62da7b5da62d4bf5e5f9f8938e" args="(ClientTest &amp;client, SyncSource &amp;source, const char *file)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g6f8c5e62da7b5da62d4bf5e5f9f8938e">ClientTest::import</a> (<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, <a class="el" href="classSyncSource.html">SyncSource</a> &amp;source, const char *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">utility function for importing items with blank lines as separator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g489f26d3ca7ec7dec96b14bc81b89dc0"></a><!-- doxytag: member="ClientTest::compare" ref="g489f26d3ca7ec7dec96b14bc81b89dc0" args="(ClientTest &amp;client, const char *fileA, const char *fileB)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g489f26d3ca7ec7dec96b14bc81b89dc0">ClientTest::compare</a> (<a class="el" href="classClientTest.html">ClientTest</a> &amp;client, const char *fileA, const char *fileB)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">utility function for comparing vCard and iCal files with the external synccompare.pl Perl script <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#gf7c1d6ba20efac0427e67f9791a3cd79">ClientTest::postSync</a> (int res, const std::string &amp;logname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is called after successful <a class="el" href="classClientTest.html#5e5a95277a8c953307c6c4c9415fe627">sync()</a> calls (res == 0) as well as after unsuccessful ones (res != 1).  <a href="#gf7c1d6ba20efac0427e67f9791a3cd79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g7b51aaa5b68b806d3719e7d74e4c2bc0">ClientTest::getTestData</a> (const char *type, Config &amp;config)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A derived class can use this call to get default test cases, but still has to add callbacks which create sources and execute a sync session.  <a href="#g7b51aaa5b68b806d3719e7d74e4c2bc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ClientTest.html#g1e939e2ba85b91dc7b0bdef7668ec34d">CheckSyncReport::check</a> (int res, <a class="el" href="classSyncReport.html">SyncReport</a> &amp;report) const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">checks that the sync completed as expected and throws CPPUnit exceptions if something is wrong  <a href="#g1e939e2ba85b91dc7b0bdef7668ec34d"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gec894e9ea4a001e35dd206b4ff4a5273"></a><!-- doxytag: member="ClientTest::syncListener" ref="gec894e9ea4a001e35dd206b4ff4a5273" args="" -->
ClientListener&nbsp;</td><td class="memItemRight" valign="bottom"><b>syncListener</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The testing framework of the C++ client library is based on CPPUnit. 
<p>
It fulfills several different goals:<ul>
<li>testing of the library itself<ul>
<li>unit testing of individual classes</li><li>full end-to-end tests of synchronization in different configurations</li></ul>
</li><li>regular testing of a SyncML server</li><li>testing of SyncML clients built on top of the library</li></ul>
<p>
Some of the design goals were:<ul>
<li>a simple, unified test runner on all platforms</li><li>it should be possible to add tests either directly in the .cpp which implements a class or in a separate file; if done in the class .cpp file then the extra code should be protected by an ifdef so that it is possible to choose whether it is in the released library or not</li><li>adding tests should not require changes in a central file</li></ul>
<p>
The test runner "client-test" is implemented in client-test-main.cpp. It automatically assembles all CPPUnit tests it was linked against and runs them all if started without parameters. Output is ASCII. The return code indicates success or failure of any test. "-h|--help" print some usage information and a full list of all available tests. Tests or test groups as printed in that list can be given as command line parameters to run just these tests. Because tests do not communicate directly with the command line front-end, they must be passed parameters via environment variables. See the description of <a class="el" href="classTestFileSource.html">TestFileSource</a> for further information about running those end-to-end synchronization tests.<p>
The test runner itself also understands some environment variables: CLIENT_TEST_FAILURES can be set to a comma separated list of tests which are allowed to fail without affecting the return code of the test runner.<p>
On Linux the test runner supports setting a timeout which is triggered if a test runs for more than the number of seconds set in the environment variable CLIENT_TEST_ALARM. This relies on signals and therefore is disabled in compilations on Windows with an ifdef HAVE_SIGNALS_H.<p>
Because of the dependency on CPPUnit the testing needs to be enabled explicitly. This can be done separately for tests embedded in the object files of the library (unit tests) and the end-to-end synchronization (integration tests) which can be used with release versions of the library.<p>
On POSIX systems the configure --enable-integration-test and --enable-unit-tests switches enable the testing. "make check" automatically executes the unit tests.<p>
On Windows the Visual Studio project file build/win32/cppunit.sln was prepared to build the "client-test" executable. Because it uses the standard win32.vcproj, some changes are necessary to enable unit tests:<ul>
<li>replace DISABLE_UNIT_TESTS with ENABLE_UNIT_TESTS in the preprocessor settings</li><li>put cppunit-1.12.0 into the same directory as the 3x directory that contains the client-api/native directory (other layouts are of course possible, just change the include and library search paths)</li></ul>
<p>
Unit tests are only found if they are pulled into the executable. On Linux this is done by searching for variables with a special name, created by the FUNAMBOL_TEST_SUITE_REGISTRATION() macro in <a class="el" href="test_8h-source.html">test.h</a>, and setting link flags on the fly. On Windows an additional C file with references to these variables is used instead. This is done by a Python script, thus python.exe must be installed and found in the search path of Visual Studio. Any suggestion how to avoid the dependency on external scripting tools without having to manually register tests in a central file is welcome...<p>
The integration tests depend on auxiliary files (test/synccompare.pl and test/testcases) which must be found in the directory where the test is run. On Linux the makefile rules automatically copy these, but the Visual Studio project file does not. Note that test/synccompare.pl is written in Perl (and thus creates another external dependency) because a) C/C++ do not have a standard library to implement the complex regular pattern matching/replace done in that script and b) the script is also meant to be shipped with clients (SyncEvolution does that) and thus needs to run on as many systems as possible. Perl is still the most universally available scripting language for that purpose.<p>
Adding new unit tests is best done by following the example in src/c++/common/base/util/BasicTime.cpp.<p>
Regular testing of a server can be done by using the reference data provided together with <a class="el" href="classClientTest.html">ClientTest</a> and synchronizing the server against simple files on the client side via a <a class="el" href="classTestFileSource.html">TestFileSource</a>. This is what enabling the integration tests adds to the "client-test" binary. By keeping the client side fixed regressions in the server can be detected. Regular testing of the client library can be done by testing the current client library source against stable servers.<p>
For testing a client based on the C++ library the client developer needs to implement the <a class="el" href="classClientTest.html">ClientTest</a> interface. There are some additional requirements for the client's <a class="el" href="classSyncSource.html">SyncSource</a> implementations:<ul>
<li>they must support more than one local database so that the same client host running the "client-test" binary can act as two different clients</li><li>they must support change tracking for more than just the server and accessing the databases via <a class="el" href="classSyncSource.html">SyncSource</a> instances so that the testing frame work can synchronize, then add/remove/update items and/or list changes without affecting the state of the client with respect to its server</li></ul>
<p>
The <a class="el" href="classTestFileSource.html">TestFileSource</a> is an example how the <a class="el" href="classClientTest.html">ClientTest</a> interface could be implemented. <hr><h2>Function Documentation</h2>
<a class="anchor" name="g1e939e2ba85b91dc7b0bdef7668ec34d"></a><!-- doxytag: member="CheckSyncReport::check" ref="g1e939e2ba85b91dc7b0bdef7668ec34d" args="(int res, SyncReport &amp;report) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CheckSyncReport::check           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSyncReport.html">SyncReport</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>report</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
checks that the sync completed as expected and throws CPPUnit exceptions if something is wrong 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&nbsp;</td><td>return code from SyncClient::sync() </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>report</em>&nbsp;</td><td>the sync report stored in the <a class="el" href="classSyncClient.html">SyncClient</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ga71193120c1176e08647ccdf9e5f4548"></a><!-- doxytag: member="LocalTests::compareDatabases" ref="ga71193120c1176e08647ccdf9e5f4548" args="(const char *refFile, SyncSource &amp;copy, bool raiseAssert=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LocalTests::compareDatabases           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>refFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSyncSource.html">SyncSource</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>raiseAssert</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
takes two databases, exports them, then compares them using synccompare 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>refFile</em>&nbsp;</td><td>existing file with source reference items, NULL uses a dump of sync source A instead </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy</em>&nbsp;</td><td>a sync source which contains the copied items, begin/endSync will be called </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>raiseAssert</em>&nbsp;</td><td>raise assertion if comparison yields differences (defaults to true) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb4b747156b72636a3b7048dcc1787799"></a><!-- doxytag: member="ClientTest.cpp::countItemsOfType" ref="gb4b747156b72636a3b7048dcc1787799" args="(SyncSource *source, itemType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int countItemsOfType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSyncSource.html">SyncSource</a> *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">itemType&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
utility function which counts items of a certain kind known to the sync source 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>valid source ready to iterate; NULL triggers an assert </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>itemType</em>&nbsp;</td><td>determines which iterator functions are used </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of valid items iterated over </dd></dl>

</div>
</div><p>
<a class="anchor" name="g26ded0f915248600703d73380b3b3b24"></a><!-- doxytag: member="ClientTest::createLocalTests" ref="g26ded0f915248600703d73380b3b3b24" args="(const std::string &amp;name, int sourceParam, ClientTest::Config &amp;co)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLocalTests.html">LocalTests</a> * ClientTest::createLocalTests           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sourceParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structClientTest_1_1Config.html">ClientTest::Config</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>co</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an instance of <a class="el" href="classLocalTests.html">LocalTests</a> (default implementation) or a class derived from it. 
<p>
<a class="el" href="classLocalTests.html">LocalTests</a> provides tests which cover the <a class="el" href="classSyncSource.html">SyncSource</a> interface and can be executed without a SyncML server. It also contains utility functions for working with SyncSources.<p>
A <a class="el" href="classClientTest.html">ClientTest</a> implementation can, but doesn't have to extend these tests by instantiating a derived class here. 
</div>
</div><p>
<a class="anchor" name="g0fa32aef3b2e3423b12e6ae3df7a596c"></a><!-- doxytag: member="ClientTest::createSyncTests" ref="g0fa32aef3b2e3423b12e6ae3df7a596c" args="(const std::string &amp;name, std::vector&lt; int &gt; sourceIndices, bool isClientA=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSyncTests.html">SyncTests</a> * ClientTest::createSyncTests           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&nbsp;</td>
          <td class="paramname"> <em>sourceIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isClientA</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an instance of <a class="el" href="classSyncTests.html">SyncTests</a> (default) or a class derived from it. 
<p>
<a class="el" href="classSyncTests.html">SyncTests</a> provides tests which cover the actual interaction with a SyncML server.<p>
A <a class="el" href="classClientTest.html">ClientTest</a> implementation can, but doesn't have to extend these tests by instantiating a derived class here. 
</div>
</div><p>
<a class="anchor" name="g7b51aaa5b68b806d3719e7d74e4c2bc0"></a><!-- doxytag: member="ClientTest::getTestData" ref="g7b51aaa5b68b806d3719e7d74e4c2bc0" args="(const char *type, Config &amp;config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ClientTest::getTestData           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structClientTest_1_1Config.html">Config</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>config</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A derived class can use this call to get default test cases, but still has to add callbacks which create sources and execute a sync session. 
<p>
Some of the test cases are compiled into the library, other depend on the auxiliary files from the "test" directory. Currently supported types:<ul>
<li>vcard30 = vCard 3.0 contacts</li><li>vcard21 = vCard 2.1 contacts</li><li>ical20 = iCal 2.0 events</li><li>vcal10 = vCal 1.0 events</li><li>itodo20 = iCal 2.0 tasks </li></ul>

</div>
</div><p>
<a class="anchor" name="g97b2b3724b5378862453e8ddf4a1fa80"></a><!-- doxytag: member="LocalTests::insert" ref="g97b2b3724b5378862453e8ddf4a1fa80" args="(CreateSource createSource, const char *data, bool relaxed=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LocalTests::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCreateSource.html">CreateSource</a>&nbsp;</td>
          <td class="paramname"> <em>createSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>relaxed</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
opens source and inserts the given item; can be called regardless whether the data source already contains items or not 
<p>
The type of the item is unset; it is assumed that the source can handle that.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>relaxed</em>&nbsp;</td><td>if true, then disable some of the additional checks after adding the item </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the UID of the inserted item </dd></dl>

</div>
</div><p>
<a class="anchor" name="g08c17db8b00624d8dc940d882dc8a336"></a><!-- doxytag: member="LocalTests::insertManyItems" ref="g08c17db8b00624d8dc940d882dc8a336" args="(CreateSource createSource, int startIndex=1, int numItems=0, int size=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LocalTests::insertManyItems           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCreateSource.html">CreateSource</a>&nbsp;</td>
          <td class="paramname"> <em>createSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>startIndex</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numItems</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
insert artificial items, number of them determined by TEST_EVOLUTION_NUM_ITEMS unless passed explicitly 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>createSource</em>&nbsp;</td><td>a factory for the sync source that is to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startIndex</em>&nbsp;</td><td>IDs are generated starting with this value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numItems</em>&nbsp;</td><td>number of items to be inserted if non-null, otherwise TEST_EVOLUTION_NUM_ITEMS is used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>minimum size for new items </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>number of items inserted </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf7c1d6ba20efac0427e67f9791a3cd79"></a><!-- doxytag: member="ClientTest::postSync" ref="gf7c1d6ba20efac0427e67f9791a3cd79" args="(int res, const std::string &amp;logname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USE_NAMESPACE void ClientTest::postSync           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>logname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is called after successful <a class="el" href="classClientTest.html#5e5a95277a8c953307c6c4c9415fe627">sync()</a> calls (res == 0) as well as after unsuccessful ones (res != 1). 
<p>
The default implementation sleeps for the number of seconds specified when constructing this instance and copies the server log if one was named.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>res</em>&nbsp;</td><td>result of <a class="el" href="classClientTest.html#5e5a95277a8c953307c6c4c9415fe627">sync()</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>logname</em>&nbsp;</td><td>base name of the current sync log (without ".client.[AB].log" suffix) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g44bbf4c7cf9b7dbce51b9f4eacf5a064"></a><!-- doxytag: member="ClientTest::registerTests" ref="g44bbf4c7cf9b7dbce51b9f4eacf5a064" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ClientTest::registerTests           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function registers tests using this instance of <a class="el" href="classClientTest.html">ClientTest</a> for later use during a test run. 
<p>
The instance must remain valid until after the tests were run. To run them use a separate test runner, like the one from client-test-main.cpp. 
</div>
</div><p>
<a class="anchor" name="g6d20c34c6796ec6caec7bfc19be3270d"></a><!-- doxytag: member="LocalTests::update" ref="g6d20c34c6796ec6caec7bfc19be3270d" args="(CreateSource createSource, const char *data, bool check=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LocalTests::update           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCreateSource.html">CreateSource</a>&nbsp;</td>
          <td class="paramname"> <em>createSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>check</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
assumes that exactly one element is currently inserted and updates it with the given item 
<p>
The type of the item is cleared, as in <a class="el" href="group__ClientTest.html#g97b2b3724b5378862453e8ddf4a1fa80">insert()</a> above.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>if true, then reopen the source and verify that the reported items are as expected </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Fri Jul 25 15:04:15 2008 for Funambol C++ Client Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
